/**
 * Minified by jsDelivr using Terser v5.10.0.
 * Original file: /npm/monaco-editor@0.33.0/esm/vs/platform/instantiation/common/instantiationService.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import{IdleValue}from"../../../base/common/async.js";import{illegalState}from"../../../base/common/errors.js";import{SyncDescriptor}from"./descriptors.js";import{Graph}from"./graph.js";import{IInstantiationService,_util}from"./instantiation.js";import{ServiceCollection}from"./serviceCollection.js";const _enableTracing=!1;class CyclicDependencyError extends Error{constructor(e){var t;super("cyclic dependency between services"),this.message=null!==(t=e.findCycleSlow())&&void 0!==t?t:`UNABLE to detect cycle, dumping graph: \n${e.toString()}`}}export class InstantiationService{constructor(e=new ServiceCollection,t=!1,r){this._activeInstantiations=new Set,this._services=e,this._strict=t,this._parent=r,this._services.set(IInstantiationService,this)}createChild(e){return new InstantiationService(e,this._strict,this)}invokeFunction(e,...t){let r=Trace.traceInvocation(e),n=!1;try{return e({get:e=>{if(n)throw illegalState("service accessor is only valid during the invocation of its target method");const t=this._getOrCreateServiceInstance(e,r);if(!t)throw new Error(`[invokeFunction] unknown service '${e}'`);return t}},...t)}finally{n=!0,r.stop()}}createInstance(e,...t){let r,n;return e instanceof SyncDescriptor?(r=Trace.traceCreation(e.ctor),n=this._createInstance(e.ctor,e.staticArguments.concat(t),r)):(r=Trace.traceCreation(e),n=this._createInstance(e,t,r)),r.stop(),n}_createInstance(e,t=[],r){let n=_util.getServiceDependencies(e).sort(((e,t)=>e.index-t.index)),i=[];for(const t of n){let n=this._getOrCreateServiceInstance(t.id,r);n||this._throwIfStrict(`[createInstance] ${e.name} depends on UNKNOWN service ${t.id}.`,!1),i.push(n)}let s=n.length>0?n[0].index:t.length;if(t.length!==s){console.warn(`[createInstance] First service dependency of ${e.name} at position ${s+1} conflicts with ${t.length} static arguments`);let r=s-t.length;t=r>0?t.concat(new Array(r)):t.slice(0,s)}return new e(...[...t,...i])}_setServiceInstance(e,t){if(this._services.get(e)instanceof SyncDescriptor)this._services.set(e,t);else{if(!this._parent)throw new Error("illegalState - setting UNKNOWN service instance");this._parent._setServiceInstance(e,t)}}_getServiceInstanceOrDescriptor(e){let t=this._services.get(e);return!t&&this._parent?this._parent._getServiceInstanceOrDescriptor(e):t}_getOrCreateServiceInstance(e,t){let r=this._getServiceInstanceOrDescriptor(e);return r instanceof SyncDescriptor?this._safeCreateAndCacheServiceInstance(e,r,t.branch(e,!0)):(t.branch(e,!1),r)}_safeCreateAndCacheServiceInstance(e,t,r){if(this._activeInstantiations.has(e))throw new Error(`illegal state - RECURSIVELY instantiating service '${e}'`);this._activeInstantiations.add(e);try{return this._createAndCacheServiceInstance(e,t,r)}finally{this._activeInstantiations.delete(e)}}_createAndCacheServiceInstance(e,t,r){const n=new Graph((e=>e.id.toString()));let i=0;const s=[{id:e,desc:t,_trace:r}];for(;s.length;){const t=s.pop();if(n.lookupOrInsertNode(t),i++>1e3)throw new CyclicDependencyError(n);for(let r of _util.getServiceDependencies(t.desc.ctor)){let i=this._getServiceInstanceOrDescriptor(r.id);if(i||this._throwIfStrict(`[createInstance] ${e} depends on ${r.id} which is NOT registered.`,!0),i instanceof SyncDescriptor){const e={id:r.id,desc:i,_trace:t._trace.branch(r.id,!0)};n.insertEdge(t,e),s.push(e)}}}for(;;){const e=n.roots();if(0===e.length){if(!n.isEmpty())throw new CyclicDependencyError(n);break}for(const{data:t}of e){if(this._getServiceInstanceOrDescriptor(t.id)instanceof SyncDescriptor){const e=this._createServiceInstanceWithOwner(t.id,t.desc.ctor,t.desc.staticArguments,t.desc.supportsDelayedInstantiation,t._trace);this._setServiceInstance(t.id,e)}n.removeNode(t)}}return this._getServiceInstanceOrDescriptor(e)}_createServiceInstanceWithOwner(e,t,r=[],n,i){if(this._services.get(e)instanceof SyncDescriptor)return this._createServiceInstance(t,r,n,i);if(this._parent)return this._parent._createServiceInstanceWithOwner(e,t,r,n,i);throw new Error(`illegalState - creating UNKNOWN service instance ${t.name}`)}_createServiceInstance(e,t=[],r,n){if(r){const r=new IdleValue((()=>this._createInstance(e,t,n)));return new Proxy(Object.create(null),{get(e,t){if(t in e)return e[t];let n=r.value,i=n[t];return"function"!=typeof i||(i=i.bind(n),e[t]=i),i},set:(e,t,n)=>(r.value[t]=n,!0)})}return this._createInstance(e,t,n)}_throwIfStrict(e,t){if(t&&console.warn(t),this._strict)throw new Error(e)}}export class Trace{constructor(e,t){this.type=e,this.name=t,this._start=Date.now(),this._dep=[]}static traceInvocation(e){return Trace._None}static traceCreation(e){return Trace._None}branch(e,t){let r=new Trace(2,e.toString());return this._dep.push([e,t,r]),r}stop(){let e=Date.now()-this._start;Trace._totals+=e;let t=!1;let r=[`${0===this.type?"CREATE":"CALL"} ${this.name}`,`${function e(r,n){let i=[],s=new Array(r+1).join("\t");for(const[c,a,o]of n._dep)if(a&&o){t=!0,i.push(`${s}CREATES -> ${c}`);let n=e(r+1,o);n&&i.push(n)}else i.push(`${s}uses -> ${c}`);return i.join("\n")}(1,this)}`,`DONE, took ${e.toFixed(2)}ms (grand total ${Trace._totals.toFixed(2)}ms)`];(e>2||t)&&console.log(r.join("\n"))}}Trace._None=new class extends Trace{constructor(){super(-1,null)}stop(){}branch(){return this}},Trace._totals=0;
//# sourceMappingURL=/sm/4d5384b9194262f37317c5528906eb411f11906cb27aa67236d5ae860a26be26.map