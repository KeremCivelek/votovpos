/**
 * Minified by jsDelivr using Terser v5.7.1.
 * Original file: /npm/monaco-editor@0.27.0/esm/vs/editor/contrib/folding/syntaxRangeProvider.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import{onUnexpectedExternalError}from"../../../base/common/errors.js";import{MAX_LINE_NUMBER,FoldingRegions}from"./foldingRanges.js";import{DisposableStore}from"../../../base/common/lifecycle.js";const MAX_FOLDING_REGIONS=5e3,foldingContext={};export const ID_SYNTAX_PROVIDER="syntax";export class SyntaxRangeProvider{constructor(t,e,n,s=5e3){this.editorModel=t,this.providers=e,this.limit=s,this.id="syntax";for(const t of e)"function"==typeof t.onDidChange&&(this.disposables||(this.disposables=new DisposableStore),this.disposables.add(t.onDidChange(n)))}compute(t){return collectSyntaxRanges(this.providers,this.editorModel,t).then((t=>{if(t){return sanitizeRanges(t,this.limit)}return null}))}dispose(){var t;null===(t=this.disposables)||void 0===t||t.dispose()}}function collectSyntaxRanges(t,e,n){let s=null,i=t.map(((t,i)=>Promise.resolve(t.provideFoldingRanges(e,foldingContext,n)).then((t=>{if(!n.isCancellationRequested&&Array.isArray(t)){Array.isArray(s)||(s=[]);let n=e.getLineCount();for(let e of t)e.start>0&&e.end>e.start&&e.end<=n&&s.push({start:e.start,end:e.end,rank:i,kind:e.kind})}}),onUnexpectedExternalError)));return Promise.all(i).then((t=>s))}export class RangesCollector{constructor(t){this._startIndexes=[],this._endIndexes=[],this._nestingLevels=[],this._nestingLevelCounts=[],this._types=[],this._length=0,this._foldingRangesLimit=t}add(t,e,n,s){if(t>MAX_LINE_NUMBER||e>MAX_LINE_NUMBER)return;let i=this._length;this._startIndexes[i]=t,this._endIndexes[i]=e,this._nestingLevels[i]=s,this._types[i]=n,this._length++,s<30&&(this._nestingLevelCounts[s]=(this._nestingLevelCounts[s]||0)+1)}toIndentRanges(){if(this._length<=this._foldingRangesLimit){let t=new Uint32Array(this._length),e=new Uint32Array(this._length);for(let n=0;n<this._length;n++)t[n]=this._startIndexes[n],e[n]=this._endIndexes[n];return new FoldingRegions(t,e,this._types)}{let t=0,e=this._nestingLevelCounts.length;for(let n=0;n<this._nestingLevelCounts.length;n++){let s=this._nestingLevelCounts[n];if(s){if(s+t>this._foldingRangesLimit){e=n;break}t+=s}}let n=new Uint32Array(this._foldingRangesLimit),s=new Uint32Array(this._foldingRangesLimit),i=[];for(let r=0,o=0;r<this._length;r++){let l=this._nestingLevels[r];(l<e||l===e&&t++<this._foldingRangesLimit)&&(n[o]=this._startIndexes[r],s[o]=this._endIndexes[r],i[o]=this._types[r],o++)}return new FoldingRegions(n,s,i)}}}export function sanitizeRanges(t,e){let n,s=t.sort(((t,e)=>{let n=t.start-e.start;return 0===n&&(n=t.rank-e.rank),n})),i=new RangesCollector(e),r=[];for(let t of s)if(n){if(t.start>n.start)if(t.end<=n.end)r.push(n),n=t,i.add(t.start,t.end,t.kind&&t.kind.value,r.length);else{if(t.start>n.end){do{n=r.pop()}while(n&&t.start>n.end);n&&r.push(n),n=t}i.add(t.start,t.end,t.kind&&t.kind.value,r.length)}}else n=t,i.add(t.start,t.end,t.kind&&t.kind.value,r.length);return i.toIndentRanges()}
//# sourceMappingURL=/sm/bd7ad3ad3a02c1462f5ad329501dd5386f618a64569af33dc765811c9af1ab09.map