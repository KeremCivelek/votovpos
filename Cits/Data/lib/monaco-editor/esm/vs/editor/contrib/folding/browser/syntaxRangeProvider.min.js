/**
 * Minified by jsDelivr using Terser v5.10.0.
 * Original file: /npm/monaco-editor@0.33.0/esm/vs/editor/contrib/folding/browser/syntaxRangeProvider.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import{onUnexpectedExternalError}from"../../../../base/common/errors.js";import{DisposableStore}from"../../../../base/common/lifecycle.js";import{FoldingRegions,MAX_LINE_NUMBER}from"./foldingRanges.js";const foldingContext={};export const ID_SYNTAX_PROVIDER="syntax";export class SyntaxRangeProvider{constructor(t,e,n,s){this.editorModel=t,this.providers=e,this.limit=s,this.id="syntax";for(const t of e)"function"==typeof t.onDidChange&&(this.disposables||(this.disposables=new DisposableStore),this.disposables.add(t.onDidChange(n)))}compute(t,e){return collectSyntaxRanges(this.providers,this.editorModel,t).then((t=>{if(t){return sanitizeRanges(t,this.limit,e)}return null}))}dispose(){var t;null===(t=this.disposables)||void 0===t||t.dispose()}}function collectSyntaxRanges(t,e,n){let s=null,i=t.map(((t,i)=>Promise.resolve(t.provideFoldingRanges(e,foldingContext,n)).then((t=>{if(!n.isCancellationRequested&&Array.isArray(t)){Array.isArray(s)||(s=[]);let n=e.getLineCount();for(let e of t)e.start>0&&e.end>e.start&&e.end<=n&&s.push({start:e.start,end:e.end,rank:i,kind:e.kind})}}),onUnexpectedExternalError)));return Promise.all(i).then((t=>s))}export class RangesCollector{constructor(t,e){this._notifyTooManyRegions=e,this._startIndexes=[],this._endIndexes=[],this._nestingLevels=[],this._nestingLevelCounts=[],this._types=[],this._length=0,this._foldingRangesLimit=t}add(t,e,n,s){if(t>MAX_LINE_NUMBER||e>MAX_LINE_NUMBER)return;let i=this._length;this._startIndexes[i]=t,this._endIndexes[i]=e,this._nestingLevels[i]=s,this._types[i]=n,this._length++,s<30&&(this._nestingLevelCounts[s]=(this._nestingLevelCounts[s]||0)+1)}toIndentRanges(){if(this._length<=this._foldingRangesLimit){let t=new Uint32Array(this._length),e=new Uint32Array(this._length);for(let n=0;n<this._length;n++)t[n]=this._startIndexes[n],e[n]=this._endIndexes[n];return new FoldingRegions(t,e,this._types)}{this._notifyTooManyRegions&&this._notifyTooManyRegions(this._foldingRangesLimit);let t=0,e=this._nestingLevelCounts.length;for(let n=0;n<this._nestingLevelCounts.length;n++){let s=this._nestingLevelCounts[n];if(s){if(s+t>this._foldingRangesLimit){e=n;break}t+=s}}let n=new Uint32Array(this._foldingRangesLimit),s=new Uint32Array(this._foldingRangesLimit),i=[];for(let o=0,r=0;o<this._length;o++){let l=this._nestingLevels[o];(l<e||l===e&&t++<this._foldingRangesLimit)&&(n[r]=this._startIndexes[o],s[r]=this._endIndexes[o],i[r]=this._types[o],r++)}return new FoldingRegions(n,s,i)}}}export function sanitizeRanges(t,e,n){let s,i=t.sort(((t,e)=>{let n=t.start-e.start;return 0===n&&(n=t.rank-e.rank),n})),o=new RangesCollector(e,n),r=[];for(let t of i)if(s){if(t.start>s.start)if(t.end<=s.end)r.push(s),s=t,o.add(t.start,t.end,t.kind&&t.kind.value,r.length);else{if(t.start>s.end){do{s=r.pop()}while(s&&t.start>s.end);s&&r.push(s),s=t}o.add(t.start,t.end,t.kind&&t.kind.value,r.length)}}else s=t,o.add(t.start,t.end,t.kind&&t.kind.value,r.length);return o.toIndentRanges()}
//# sourceMappingURL=/sm/801e3c01a392bf84f73add79d3b08feacd497c67e2c09151d52dc5bbc56ef13a.map