/**
 * Minified by jsDelivr using Terser v5.7.1.
 * Original file: /npm/monaco-editor@0.27.0/esm/vs/editor/common/controller/cursorDeleteOperations.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import*as strings from"../../../base/common/strings.js";import{ReplaceCommand}from"../commands/replaceCommand.js";import{CursorColumns,EditOperationResult,isQuote}from"./cursorCommon.js";import{MoveOperations}from"./cursorMoveOperations.js";import{Range}from"../core/range.js";import{Position}from"../core/position.js";export class DeleteOperations{static deleteRight(e,t,n,o){let r=[],i=3!==e;for(let e=0,l=o.length;e<l;e++){const l=o[e];let s=l;if(s.isEmpty()){let e=l.getPosition(),o=MoveOperations.right(t,n,e);s=new Range(o.lineNumber,o.column,e.lineNumber,e.column)}s.isEmpty()?r[e]=null:(s.startLineNumber!==s.endLineNumber&&(i=!0),r[e]=new ReplaceCommand(s,""))}return[i,r]}static isAutoClosingPairDelete(e,t,n,o,r,i,l){if("never"===t&&"never"===n)return!1;if("never"===e)return!1;for(let s=0,u=i.length;s<u;s++){const u=i[s],m=u.getPosition();if(!u.isEmpty())return!1;const a=r.getLineContent(m.lineNumber);if(m.column<2||m.column>=a.length+1)return!1;const c=a.charAt(m.column-2),g=o.get(c);if(!g)return!1;if(isQuote(c)){if("never"===n)return!1}else if("never"===t)return!1;const f=a.charAt(m.column-1);let p=!1;for(const e of g)e.open===c&&e.close===f&&(p=!0);if(!p)return!1;if("auto"===e){let e=!1;for(let t=0,n=l.length;t<n;t++){const n=l[t];if(m.lineNumber===n.startLineNumber&&m.column===n.startColumn){e=!0;break}}if(!e)return!1}}return!0}static _runAutoClosingPairDelete(e,t,n){let o=[];for(let e=0,t=n.length;e<t;e++){const t=n[e].getPosition(),r=new Range(t.lineNumber,t.column-1,t.lineNumber,t.column+1);o[e]=new ReplaceCommand(r,"")}return[!0,o]}static deleteLeft(e,t,n,o,r){if(this.isAutoClosingPairDelete(t.autoClosingDelete,t.autoClosingBrackets,t.autoClosingQuotes,t.autoClosingPairs.autoClosingPairsOpenByEnd,n,o,r))return this._runAutoClosingPairDelete(t,n,o);const i=[];let l=2!==e;for(let e=0,r=o.length;e<r;e++){let r=DeleteOperations.getDeleteRange(o[e],n,t);r.isEmpty()?i[e]=null:(r.startLineNumber!==r.endLineNumber&&(l=!0),i[e]=new ReplaceCommand(r,""))}return[l,i]}static getDeleteRange(e,t,n){if(!e.isEmpty())return e;const o=e.getPosition();if(n.useTabStops&&o.column>1){const e=t.getLineContent(o.lineNumber),r=strings.firstNonWhitespaceIndex(e),i=-1===r?e.length+1:r+1;if(o.column<=i){const e=CursorColumns.visibleColumnFromColumn2(n,t,o),r=CursorColumns.prevIndentTabStop(e,n.indentSize),i=CursorColumns.columnFromVisibleColumn2(n,t,o.lineNumber,r);return new Range(o.lineNumber,i,o.lineNumber,o.column)}}return Range.fromPositions(DeleteOperations.getPositionAfterDeleteLeft(o,t),o)}static getPositionAfterDeleteLeft(e,t){if(e.column>1){const n=strings.getLeftDeleteOffset(e.column-1,t.getLineContent(e.lineNumber));return e.with(void 0,n+1)}if(e.lineNumber>1){const n=e.lineNumber-1;return new Position(n,t.getLineMaxColumn(n))}return e}static cut(e,t,n){let o=[];for(let r=0,i=n.length;r<i;r++){const i=n[r];if(i.isEmpty())if(e.emptySelectionClipboard){let e,n,l,s,u=i.getPosition();u.lineNumber<t.getLineCount()?(e=u.lineNumber,n=1,l=u.lineNumber+1,s=1):u.lineNumber>1?(e=u.lineNumber-1,n=t.getLineMaxColumn(u.lineNumber-1),l=u.lineNumber,s=t.getLineMaxColumn(u.lineNumber)):(e=u.lineNumber,n=1,l=u.lineNumber,s=t.getLineMaxColumn(u.lineNumber));let m=new Range(e,n,l,s);m.isEmpty()?o[r]=null:o[r]=new ReplaceCommand(m,"")}else o[r]=null;else o[r]=new ReplaceCommand(i,"")}return new EditOperationResult(0,o,{shouldPushStackElementBefore:!0,shouldPushStackElementAfter:!0})}}
//# sourceMappingURL=/sm/121ed319148110ba56b904e7b8bc5b2e4382c11360f8fa1d3cb9b154b83b078f.map