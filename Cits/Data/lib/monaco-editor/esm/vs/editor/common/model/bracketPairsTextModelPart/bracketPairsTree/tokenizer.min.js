/**
 * Minified by jsDelivr using Terser v5.10.0.
 * Original file: /npm/monaco-editor@0.33.0/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/tokenizer.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import{NotSupportedError}from"../../../../../base/common/errors.js";import{TokenMetadata}from"../../../languages.js";import{TextAstNode}from"./ast.js";import{lengthAdd,lengthDiff,lengthGetColumnCountIfZeroLineCount,lengthToObj,lengthZero,toLength}from"./length.js";import{SmallImmutableSet}from"./smallImmutableSet.js";export class Token{constructor(e,t,n,s,i){this.length=e,this.kind=t,this.bracketId=n,this.bracketIds=s,this.astNode=i}}export class TextBufferTokenizer{constructor(e,t){this.textModel=e,this.bracketTokens=t,this.reader=new NonPeekableTextBufferTokenizer(this.textModel,this.bracketTokens),this._offset=lengthZero,this.didPeek=!1,this.peeked=null,this.textBufferLineCount=e.getLineCount(),this.textBufferLastLineLength=e.getLineLength(this.textBufferLineCount)}get offset(){return this._offset}get length(){return toLength(this.textBufferLineCount,this.textBufferLastLineLength)}skip(e){this.didPeek=!1,this._offset=lengthAdd(this._offset,e);const t=lengthToObj(this._offset);this.reader.setPosition(t.lineCount,t.columnCount)}read(){let e;return this.peeked?(this.didPeek=!1,e=this.peeked):e=this.reader.read(),e&&(this._offset=lengthAdd(this._offset,e.length)),e}peek(){return this.didPeek||(this.peeked=this.reader.read(),this.didPeek=!0),this.peeked}}class NonPeekableTextBufferTokenizer{constructor(e,t){this.textModel=e,this.bracketTokens=t,this.lineIdx=0,this.line=null,this.lineCharOffset=0,this.lineTokens=null,this.lineTokenOffset=0,this.peekedToken=null,this.textBufferLineCount=e.getLineCount(),this.textBufferLastLineLength=e.getLineLength(this.textBufferLineCount)}setPosition(e,t){e===this.lineIdx?(this.lineCharOffset=t,this.lineTokenOffset=0===this.lineCharOffset?0:this.lineTokens.findTokenIndexAtOffset(this.lineCharOffset)):(this.lineIdx=e,this.lineCharOffset=t,this.line=null),this.peekedToken=null}read(){if(this.peekedToken){const e=this.peekedToken;return this.peekedToken=null,this.lineCharOffset+=lengthGetColumnCountIfZeroLineCount(e.length),e}if(this.lineIdx>this.textBufferLineCount-1||this.lineIdx===this.textBufferLineCount-1&&this.lineCharOffset>=this.textBufferLastLineLength)return null;null===this.line&&(this.lineTokens=this.textModel.getLineTokens(this.lineIdx+1),this.line=this.lineTokens.getLineContent(),this.lineTokenOffset=0===this.lineCharOffset?0:this.lineTokens.findTokenIndexAtOffset(this.lineCharOffset));const e=this.lineIdx,t=this.lineCharOffset;let n=0;for(;;){const s=this.lineTokens,i=s.getCount();let h=null;if(this.lineTokenOffset<i){const o=s.getMetadata(this.lineTokenOffset);for(;this.lineTokenOffset+1<i&&o===s.getMetadata(this.lineTokenOffset+1);)this.lineTokenOffset++;const l=0===TokenMetadata.getTokenType(o),f=s.getEndOffset(this.lineTokenOffset);if(l&&f!==this.lineCharOffset){const e=s.getLanguageId(this.lineTokenOffset),t=this.line.substring(this.lineCharOffset,f),n=this.bracketTokens.getSingleLanguageBracketTokens(e),i=n.regExpGlobal;if(i){i.lastIndex=0;const e=i.exec(t);e&&(h=n.getToken(e[0]),h&&(this.lineCharOffset+=e.index))}}if(n+=f-this.lineCharOffset,h){if(e!==this.lineIdx||t!==this.lineCharOffset){this.peekedToken=h;break}return this.lineCharOffset+=lengthGetColumnCountIfZeroLineCount(h.length),h}this.lineTokenOffset++,this.lineCharOffset=f}else{if(this.lineIdx===this.textBufferLineCount-1)break;if(this.lineIdx++,this.lineTokens=this.textModel.getLineTokens(this.lineIdx+1),this.lineTokenOffset=0,this.line=this.lineTokens.getLineContent(),this.lineCharOffset=0,n+=33,n>1e3)break}if(n>1500)break}const s=lengthDiff(e,t,this.lineIdx,this.lineCharOffset);return new Token(s,0,-1,SmallImmutableSet.getEmpty(),new TextAstNode(s))}}export class FastTokenizer{constructor(e,t){this.text=e,this._offset=lengthZero,this.idx=0;const n=t.getRegExpStr()?new RegExp(t.getRegExpStr()+"|\n","g"):null,s=[];let i,h=0,o=0,l=0,f=0;const r=new Array;for(let e=0;e<60;e++)r.push(new Token(toLength(0,e),0,-1,SmallImmutableSet.getEmpty(),new TextAstNode(toLength(0,e))));const a=new Array;for(let e=0;e<60;e++)a.push(new Token(toLength(1,e),0,-1,SmallImmutableSet.getEmpty(),new TextAstNode(toLength(1,e))));if(n)for(n.lastIndex=0;null!==(i=n.exec(e));){const e=i.index,n=i[0];if("\n"===n)h++,o=e+1;else{if(l!==e){let t;if(f===h){const n=e-l;if(n<r.length)t=r[n];else{const e=toLength(0,n);t=new Token(e,0,-1,SmallImmutableSet.getEmpty(),new TextAstNode(e))}}else{const n=h-f,s=e-o;if(1===n&&s<a.length)t=a[s];else{const e=toLength(n,s);t=new Token(e,0,-1,SmallImmutableSet.getEmpty(),new TextAstNode(e))}}s.push(t)}s.push(t.getToken(n)),l=e+n.length,f=h}}const k=e.length;if(l!==k){const e=f===h?toLength(0,k-l):toLength(h-f,k-o);s.push(new Token(e,0,-1,SmallImmutableSet.getEmpty(),new TextAstNode(e)))}this.length=toLength(h,k-o),this.tokens=s}get offset(){return this._offset}read(){return this.tokens[this.idx++]||null}peek(){return this.tokens[this.idx]||null}skip(e){throw new NotSupportedError}}
//# sourceMappingURL=/sm/5fd879cf915c92c37b777f25db0b7d81598f8e7b08bb4e99285f72b6cab26568.map