/**
 * Minified by jsDelivr using Terser v5.7.1.
 * Original file: /npm/monaco-editor@0.27.0/esm/vs/editor/common/model/tokensStore.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import*as arrays from"../../../base/common/arrays.js";import{LineTokens}from"../core/lineTokens.js";import{Position}from"../core/position.js";import{Range}from"../core/range.js";import{TokenMetadata}from"../modes.js";export function countEOL(e){let t=0,n=0,s=0,i=0;for(let r=0,o=e.length;r<o;r++){const a=e.charCodeAt(r);13===a?(0===t&&(n=r),t++,r+1<o&&10===e.charCodeAt(r+1)?(i|=2,r++):i|=3,s=r+1):10===a&&(i|=1,0===t&&(n=r),t++,s=r+1)}return 0===t&&(n=e.length),[t,n,e.length-s,i]}function getDefaultMetadata(e){return(16384|e<<0|2<<23)>>>0}const EMPTY_LINE_TOKENS=new Uint32Array(0).buffer;export class MultilineTokensBuilder{constructor(){this.tokens=[]}add(e,t){if(this.tokens.length>0){const n=this.tokens[this.tokens.length-1];if(n.startLineNumber+n.tokens.length-1+1===e)return void n.tokens.push(t)}this.tokens.push(new MultilineTokens(e,[t]))}}export class SparseEncodedTokens{constructor(e){this._tokens=e,this._tokenCount=e.length/4}toString(e){let t=[];for(let n=0;n<this._tokenCount;n++)t.push(`(${this._getDeltaLine(n)+e},${this._getStartCharacter(n)}-${this._getEndCharacter(n)})`);return`[${t.join(",")}]`}getMaxDeltaLine(){const e=this._getTokenCount();return 0===e?-1:this._getDeltaLine(e-1)}getRange(){const e=this._getTokenCount();if(0===e)return null;const t=this._getStartCharacter(0),n=this._getDeltaLine(e-1),s=this._getEndCharacter(e-1);return new Range(0,t+1,n,s+1)}_getTokenCount(){return this._tokenCount}_getDeltaLine(e){return this._tokens[4*e]}_getStartCharacter(e){return this._tokens[4*e+1]}_getEndCharacter(e){return this._tokens[4*e+2]}isEmpty(){return 0===this._getTokenCount()}getLineTokens(e){let t=0,n=this._getTokenCount()-1;for(;t<n;){const s=t+Math.floor((n-t)/2),i=this._getDeltaLine(s);if(i<e)t=s+1;else{if(!(i>e)){let i=s;for(;i>t&&this._getDeltaLine(i-1)===e;)i--;let r=s;for(;r<n&&this._getDeltaLine(r+1)===e;)r++;return new LineTokens2(this._tokens.subarray(4*i,4*r+4))}n=s-1}}return this._getDeltaLine(t)===e?new LineTokens2(this._tokens.subarray(4*t,4*t+4)):null}clear(){this._tokenCount=0}removeTokens(e,t,n,s){const i=this._tokens,r=this._tokenCount;let o=0,a=!1,l=0;for(let u=0;u<r;u++){const r=4*u,h=i[r],c=i[r+1],_=i[r+2],f=i[r+3];if((h>e||h===e&&_>=t)&&(h<n||h===n&&c<=s))a=!0;else{if(0===o&&(l=h),a){const e=4*o;i[e]=h-l,i[e+1]=c,i[e+2]=_,i[e+3]=f}o++}}return this._tokenCount=o,l}split(e,t,n,s){const i=this._tokens,r=this._tokenCount;let o=[],a=[],l=o,u=0,h=0;for(let o=0;o<r;o++){const r=4*o,c=i[r],_=i[r+1],f=i[r+2],g=i[r+3];if(c>e||c===e&&f>=t){if(c<n||c===n&&_<=s)continue;l!==a&&(l=a,u=0,h=c)}l[u++]=c-h,l[u++]=_,l[u++]=f,l[u++]=g}return[new SparseEncodedTokens(new Uint32Array(o)),new SparseEncodedTokens(new Uint32Array(a)),h]}acceptDeleteRange(e,t,n,s,i){const r=this._tokens,o=this._tokenCount,a=s-t;let l=0,u=!1;for(let h=0;h<o;h++){const c=4*h;let _=r[c],f=r[c+1],g=r[c+2];const k=r[c+3];if(_<t||_===t&&g<=n){l++;continue}if(_===t&&f<n)_===s&&g>i?g-=i-n:g=n;else if(_===t&&f===n){if(!(_===s&&g>i)){u=!0;continue}g-=i-n}else if(_<s||_===s&&f<i){if(!(_===s&&g>i)){u=!0;continue}_===t?(f=n,g=f+(g-i)):(f=0,g=f+(g-i))}else if(_>s){if(0===a&&!u){l=o;break}_-=a}else{if(!(_===s&&f>=i))throw new Error("Not possible!");e&&0===_&&(f+=e,g+=e),_-=a,f-=i-n,g-=i-n}const m=4*l;r[m]=_,r[m+1]=f,r[m+2]=g,r[m+3]=k,l++}this._tokenCount=l}acceptInsertText(e,t,n,s,i,r){const o=0===n&&1===s&&(r>=48&&r<=57||r>=65&&r<=90||r>=97&&r<=122),a=this._tokens,l=this._tokenCount;for(let r=0;r<l;r++){const l=4*r;let u=a[l],h=a[l+1],c=a[l+2];if(!(u<e||u===e&&c<t)){if(u===e&&c===t){if(!o)continue;c+=1}else if(u===e&&h<t&&t<c)0===n?c+=s:c=t;else{if(u===e&&h===t&&o)continue;if(u===e)if(u+=n,0===n)h+=s,c+=s;else{const e=c-h;h=i+(h-t),c=h+e}else u+=n}a[l]=u,a[l+1]=h,a[l+2]=c}}}}export class LineTokens2{constructor(e){this._tokens=e}getCount(){return this._tokens.length/4}getStartCharacter(e){return this._tokens[4*e+1]}getEndCharacter(e){return this._tokens[4*e+2]}getMetadata(e){return this._tokens[4*e+3]}}export class MultilineTokens2{constructor(e,t){this.startLineNumber=e,this.tokens=t,this.endLineNumber=this.startLineNumber+this.tokens.getMaxDeltaLine()}toString(){return this.tokens.toString(this.startLineNumber)}_updateEndLineNumber(){this.endLineNumber=this.startLineNumber+this.tokens.getMaxDeltaLine()}isEmpty(){return this.tokens.isEmpty()}getLineTokens(e){return this.startLineNumber<=e&&e<=this.endLineNumber?this.tokens.getLineTokens(e-this.startLineNumber):null}getRange(){const e=this.tokens.getRange();return e?new Range(this.startLineNumber+e.startLineNumber,e.startColumn,this.startLineNumber+e.endLineNumber,e.endColumn):e}removeTokens(e){const t=e.startLineNumber-this.startLineNumber,n=e.endLineNumber-this.startLineNumber;this.startLineNumber+=this.tokens.removeTokens(t,e.startColumn-1,n,e.endColumn-1),this._updateEndLineNumber()}split(e){const t=e.startLineNumber-this.startLineNumber,n=e.endLineNumber-this.startLineNumber,[s,i,r]=this.tokens.split(t,e.startColumn-1,n,e.endColumn-1);return[new MultilineTokens2(this.startLineNumber,s),new MultilineTokens2(this.startLineNumber+r,i)]}applyEdit(e,t){const[n,s,i]=countEOL(t);this.acceptEdit(e,n,s,i,t.length>0?t.charCodeAt(0):0)}acceptEdit(e,t,n,s,i){this._acceptDeleteRange(e),this._acceptInsertText(new Position(e.startLineNumber,e.startColumn),t,n,s,i),this._updateEndLineNumber()}_acceptDeleteRange(e){if(e.startLineNumber===e.endLineNumber&&e.startColumn===e.endColumn)return;const t=e.startLineNumber-this.startLineNumber,n=e.endLineNumber-this.startLineNumber;if(n<0){const e=n-t;return void(this.startLineNumber-=e)}const s=this.tokens.getMaxDeltaLine();if(!(t>=s+1)){if(t<0&&n>=s+1)return this.startLineNumber=0,void this.tokens.clear();if(t<0){const s=-t;this.startLineNumber-=s,this.tokens.acceptDeleteRange(e.startColumn-1,0,0,n,e.endColumn-1)}else this.tokens.acceptDeleteRange(0,t,e.startColumn-1,n,e.endColumn-1)}}_acceptInsertText(e,t,n,s,i){if(0===t&&0===n)return;const r=e.lineNumber-this.startLineNumber;if(r<0)return void(this.startLineNumber+=t);r>=this.tokens.getMaxDeltaLine()+1||this.tokens.acceptInsertText(r,e.column-1,t,n,s,i)}}export class MultilineTokens{constructor(e,t){this.startLineNumber=e,this.tokens=t}}function toUint32Array(e){return e instanceof Uint32Array?e:new Uint32Array(e)}export class TokensStore2{constructor(){this._pieces=[],this._isComplete=!1}flush(){this._pieces=[],this._isComplete=!1}isEmpty(){return 0===this._pieces.length}set(e,t){this._pieces=e||[],this._isComplete=t}setPartial(e,t){let n=e;if(t.length>0){const s=t[0].getRange(),i=t[t.length-1].getRange();if(!s||!i)return e;n=e.plusRange(s).plusRange(i)}let s=null;for(let e=0,t=this._pieces.length;e<t;e++){const i=this._pieces[e];if(i.endLineNumber<n.startLineNumber)continue;if(i.startLineNumber>n.endLineNumber){s=s||{index:e};break}if(i.removeTokens(n),i.isEmpty()){this._pieces.splice(e,1),e--,t--;continue}if(i.endLineNumber<n.startLineNumber)continue;if(i.startLineNumber>n.endLineNumber){s=s||{index:e};continue}const[r,o]=i.split(n);r.isEmpty()?s=s||{index:e}:o.isEmpty()||(this._pieces.splice(e,1,r,o),e++,t++,s=s||{index:e})}return s=s||{index:this._pieces.length},t.length>0&&(this._pieces=arrays.arrayInsert(this._pieces,s.index,t)),n}isComplete(){return this._isComplete}addSemanticTokens(e,t){const n=this._pieces;if(0===n.length)return t;const s=n[TokensStore2._findFirstPieceWithLine(n,e)].getLineTokens(e);if(!s)return t;const i=t.getCount(),r=s.getCount();let o=0,a=[],l=0,u=0;const h=(e,t)=>{e!==u&&(u=e,a[l++]=e,a[l++]=t)};for(let e=0;e<r;e++){const n=s.getStartCharacter(e),r=s.getEndCharacter(e),a=s.getMetadata(e),l=((1&a?2048:0)|(2&a?4096:0)|(4&a?8192:0)|(8&a?8372224:0)|(16&a?4286578688:0))>>>0,u=~l>>>0;for(;o<i&&t.getEndOffset(o)<=n;)h(t.getEndOffset(o),t.getMetadata(o)),o++;for(o<i&&t.getStartOffset(o)<n&&h(n,t.getMetadata(o));o<i&&t.getEndOffset(o)<r;)h(t.getEndOffset(o),t.getMetadata(o)&u|a&l),o++;if(o<i)h(r,t.getMetadata(o)&u|a&l),t.getEndOffset(o)===r&&o++;else{const e=Math.min(Math.max(0,o-1),i-1);h(r,t.getMetadata(e)&u|a&l)}}for(;o<i;)h(t.getEndOffset(o),t.getMetadata(o)),o++;return new LineTokens(new Uint32Array(a),t.getLineContent())}static _findFirstPieceWithLine(e,t){let n=0,s=e.length-1;for(;n<s;){let i=n+Math.floor((s-n)/2);if(e[i].endLineNumber<t)n=i+1;else{if(!(e[i].startLineNumber>t)){for(;i>n&&e[i-1].startLineNumber<=t&&t<=e[i-1].endLineNumber;)i--;return i}s=i-1}}return n}acceptEdit(e,t,n,s,i){for(const r of this._pieces)r.acceptEdit(e,t,n,s,i)}}export class TokensStore{constructor(){this._lineTokens=[],this._len=0}flush(){this._lineTokens=[],this._len=0}getTokens(e,t,n){let s=null;if(t<this._len&&(s=this._lineTokens[t]),null!==s&&s!==EMPTY_LINE_TOKENS)return new LineTokens(toUint32Array(s),n);let i=new Uint32Array(2);return i[0]=n.length,i[1]=getDefaultMetadata(e),new LineTokens(i,n)}static _massageTokens(e,t,n){const s=n?toUint32Array(n):null;if(0===t){let t=!1;if(s&&s.length>1&&(t=TokenMetadata.getLanguageId(s[1])!==e),!t)return EMPTY_LINE_TOKENS}if(!s||0===s.length){const n=new Uint32Array(2);return n[0]=t,n[1]=getDefaultMetadata(e),n.buffer}return s[s.length-2]=t,0===s.byteOffset&&s.byteLength===s.buffer.byteLength?s.buffer:s}_ensureLine(e){for(;e>=this._len;)this._lineTokens[this._len]=null,this._len++}_deleteLines(e,t){0!==t&&(e+t>this._len&&(t=this._len-e),this._lineTokens.splice(e,t),this._len-=t)}_insertLines(e,t){if(0===t)return;let n=[];for(let e=0;e<t;e++)n[e]=null;this._lineTokens=arrays.arrayInsert(this._lineTokens,e,n),this._len+=t}setTokens(e,t,n,s,i){const r=TokensStore._massageTokens(e,n,s);this._ensureLine(t);const o=this._lineTokens[t];return this._lineTokens[t]=r,!!i&&!TokensStore._equals(o,r)}static _equals(e,t){if(!e||!t)return!e&&!t;const n=toUint32Array(e),s=toUint32Array(t);if(n.length!==s.length)return!1;for(let e=0,t=n.length;e<t;e++)if(n[e]!==s[e])return!1;return!0}acceptEdit(e,t,n){this._acceptDeleteRange(e),this._acceptInsertText(new Position(e.startLineNumber,e.startColumn),t,n)}_acceptDeleteRange(e){const t=e.startLineNumber-1;if(t>=this._len)return;if(e.startLineNumber===e.endLineNumber){if(e.startColumn===e.endColumn)return;return void(this._lineTokens[t]=TokensStore._delete(this._lineTokens[t],e.startColumn-1,e.endColumn-1))}this._lineTokens[t]=TokensStore._deleteEnding(this._lineTokens[t],e.startColumn-1);const n=e.endLineNumber-1;let s=null;n<this._len&&(s=TokensStore._deleteBeginning(this._lineTokens[n],e.endColumn-1)),this._lineTokens[t]=TokensStore._append(this._lineTokens[t],s),this._deleteLines(e.startLineNumber,e.endLineNumber-e.startLineNumber)}_acceptInsertText(e,t,n){if(0===t&&0===n)return;const s=e.lineNumber-1;s>=this._len||(0!==t?(this._lineTokens[s]=TokensStore._deleteEnding(this._lineTokens[s],e.column-1),this._lineTokens[s]=TokensStore._insert(this._lineTokens[s],e.column-1,n),this._insertLines(e.lineNumber,t)):this._lineTokens[s]=TokensStore._insert(this._lineTokens[s],e.column-1,n))}static _deleteBeginning(e,t){return null===e||e===EMPTY_LINE_TOKENS?e:TokensStore._delete(e,0,t)}static _deleteEnding(e,t){if(null===e||e===EMPTY_LINE_TOKENS)return e;const n=toUint32Array(e),s=n[n.length-2];return TokensStore._delete(e,t,s)}static _delete(e,t,n){if(null===e||e===EMPTY_LINE_TOKENS||t===n)return e;const s=toUint32Array(e),i=s.length>>>1;if(0===t&&s[s.length-2]===n)return EMPTY_LINE_TOKENS;const r=LineTokens.findIndexInTokensArray(s,t),o=r>0?s[r-1<<1]:0;if(n<s[r<<1]){const o=n-t;for(let e=r;e<i;e++)s[e<<1]-=o;return e}let a,l;o!==t?(s[r<<1]=t,a=r+1<<1,l=t):(a=r<<1,l=o);const u=n-t;for(let e=r+1;e<i;e++){const t=s[e<<1]-u;t>l&&(s[a++]=t,s[a++]=s[1+(e<<1)],l=t)}if(a===s.length)return e;let h=new Uint32Array(a);return h.set(s.subarray(0,a),0),h.buffer}static _append(e,t){if(t===EMPTY_LINE_TOKENS)return e;if(e===EMPTY_LINE_TOKENS)return t;if(null===e)return e;if(null===t)return null;const n=toUint32Array(e),s=toUint32Array(t),i=s.length>>>1;let r=new Uint32Array(n.length+s.length);r.set(n,0);let o=n.length;const a=n[n.length-2];for(let e=0;e<i;e++)r[o++]=s[e<<1]+a,r[o++]=s[1+(e<<1)];return r.buffer}static _insert(e,t,n){if(null===e||e===EMPTY_LINE_TOKENS)return e;const s=toUint32Array(e),i=s.length>>>1;let r=LineTokens.findIndexInTokensArray(s,t);if(r>0){s[r-1<<1]===t&&r--}for(let e=r;e<i;e++)s[e<<1]+=n;return e}}
//# sourceMappingURL=/sm/1292860e3dcaac886472735c37d2e08b6152cb016756e3977a0db045c33b3e54.map