/**
 * Minified by jsDelivr using Terser v5.7.1.
 * Original file: /npm/monaco-editor@0.27.0/esm/vs/editor/common/core/lineTokens.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import{TokenMetadata}from"../modes.js";export class LineTokens{constructor(t,e){this._lineTokensBrand=void 0,this._tokens=t,this._tokensCount=this._tokens.length>>>1,this._text=e}static createEmpty(t){const e=LineTokens.defaultTokenMetadata,n=new Uint32Array(2);return n[0]=t.length,n[1]=e,new LineTokens(n,t)}equals(t){return t instanceof LineTokens&&this.slicedEquals(t,0,this._tokensCount)}slicedEquals(t,e,n){if(this._text!==t._text)return!1;if(this._tokensCount!==t._tokensCount)return!1;const s=e<<1,o=s+(n<<1);for(let e=s;e<o;e++)if(this._tokens[e]!==t._tokens[e])return!1;return!0}getLineContent(){return this._text}getCount(){return this._tokensCount}getStartOffset(t){return t>0?this._tokens[t-1<<1]:0}getMetadata(t){return this._tokens[1+(t<<1)]}getLanguageId(t){const e=this._tokens[1+(t<<1)];return TokenMetadata.getLanguageId(e)}getStandardTokenType(t){const e=this._tokens[1+(t<<1)];return TokenMetadata.getTokenType(e)}getForeground(t){const e=this._tokens[1+(t<<1)];return TokenMetadata.getForeground(e)}getClassName(t){const e=this._tokens[1+(t<<1)];return TokenMetadata.getClassNameFromMetadata(e)}getInlineStyle(t,e){const n=this._tokens[1+(t<<1)];return TokenMetadata.getInlineStyleFromMetadata(n,e)}getEndOffset(t){return this._tokens[t<<1]}findTokenIndexAtOffset(t){return LineTokens.findIndexInTokensArray(this._tokens,t)}inflate(){return this}sliceAndInflate(t,e,n){return new SlicedLineTokens(this,t,e,n)}static convertToEndOffset(t,e){const n=(t.length>>>1)-1;for(let e=0;e<n;e++)t[e<<1]=t[e+1<<1];t[n<<1]=e}static findIndexInTokensArray(t,e){if(t.length<=2)return 0;let n=0,s=(t.length>>>1)-1;for(;n<s;){const o=n+Math.floor((s-n)/2),r=t[o<<1];if(r===e)return o+1;r<e?n=o+1:r>e&&(s=o)}return n}withInserted(t){if(0===t.length)return this;let e=0,n=0,s="";const o=new Array;let r=0;for(;;){let i=e<this._tokensCount?this._tokens[e<<1]:-1,f=n<t.length?t[n]:null;if(-1!==i&&(null===f||i<=f.offset)){s+=this._text.substring(r,i);const t=this._tokens[1+(e<<1)];o.push(s.length,t),e++,r=i}else{if(!f)break;if(f.offset>r){s+=this._text.substring(r,f.offset);const t=this._tokens[1+(e<<1)];o.push(s.length,t),r=f.offset}s+=f.text,o.push(s.length,f.tokenMetadata),n++}}return new LineTokens(new Uint32Array(o),s)}}LineTokens.defaultTokenMetadata=16793600;export class SlicedLineTokens{constructor(t,e,n,s){this._source=t,this._startOffset=e,this._endOffset=n,this._deltaOffset=s,this._firstTokenIndex=t.findTokenIndexAtOffset(e),this._tokensCount=0;for(let e=this._firstTokenIndex,s=t.getCount();e<s;e++){if(t.getStartOffset(e)>=n)break;this._tokensCount++}}equals(t){return t instanceof SlicedLineTokens&&(this._startOffset===t._startOffset&&this._endOffset===t._endOffset&&this._deltaOffset===t._deltaOffset&&this._source.slicedEquals(t._source,this._firstTokenIndex,this._tokensCount))}getCount(){return this._tokensCount}getForeground(t){return this._source.getForeground(this._firstTokenIndex+t)}getEndOffset(t){const e=this._source.getEndOffset(this._firstTokenIndex+t);return Math.min(this._endOffset,e)-this._startOffset+this._deltaOffset}getClassName(t){return this._source.getClassName(this._firstTokenIndex+t)}getInlineStyle(t,e){return this._source.getInlineStyle(this._firstTokenIndex+t,e)}findTokenIndexAtOffset(t){return this._source.findTokenIndexAtOffset(t+this._startOffset-this._deltaOffset)-this._firstTokenIndex}}
//# sourceMappingURL=/sm/fc9f2ca02c97f36b3659aeb860a3fa6e4884cd7b05839ef8edcfacec53ca2a63.map