/**
 * Minified by jsDelivr using Terser v5.10.0.
 * Original file: /npm/monaco-editor@0.33.0/esm/vs/editor/standalone/common/monarch/monarchLexer.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import*as languages from"../../../common/languages.js";import{NullState}from"../../../common/languages/nullTokenize.js";import*as monarchCommon from"./monarchCommon.js";const CACHE_STACK_DEPTH=5;class MonarchStackElementFactory{constructor(e){this._maxCacheDepth=e,this._entries=Object.create(null)}static create(e,t){return this._INSTANCE.create(e,t)}create(e,t){if(null!==e&&e.depth>=this._maxCacheDepth)return new MonarchStackElement(e,t);let n=MonarchStackElement.getStackElementId(e);n.length>0&&(n+="|"),n+=t;let a=this._entries[n];return a||(a=new MonarchStackElement(e,t),this._entries[n]=a,a)}}MonarchStackElementFactory._INSTANCE=new MonarchStackElementFactory(5);class MonarchStackElement{constructor(e,t){this.parent=e,this.state=t,this.depth=(this.parent?this.parent.depth:0)+1}static getStackElementId(e){let t="";for(;null!==e;)t.length>0&&(t+="|"),t+=e.state,e=e.parent;return t}static _equals(e,t){for(;null!==e&&null!==t;){if(e===t)return!0;if(e.state!==t.state)return!1;e=e.parent,t=t.parent}return null===e&&null===t}equals(e){return MonarchStackElement._equals(this,e)}push(e){return MonarchStackElementFactory.create(this,e)}pop(){return this.parent}popall(){let e=this;for(;e.parent;)e=e.parent;return e}switchTo(e){return MonarchStackElementFactory.create(this.parent,e)}}class EmbeddedLanguageData{constructor(e,t){this.languageId=e,this.state=t}equals(e){return this.languageId===e.languageId&&this.state.equals(e.state)}clone(){return this.state.clone()===this.state?this:new EmbeddedLanguageData(this.languageId,this.state)}}class MonarchLineStateFactory{constructor(e){this._maxCacheDepth=e,this._entries=Object.create(null)}static create(e,t){return this._INSTANCE.create(e,t)}create(e,t){if(null!==t)return new MonarchLineState(e,t);if(null!==e&&e.depth>=this._maxCacheDepth)return new MonarchLineState(e,t);const n=MonarchStackElement.getStackElementId(e);let a=this._entries[n];return a||(a=new MonarchLineState(e,null),this._entries[n]=a,a)}}MonarchLineStateFactory._INSTANCE=new MonarchLineStateFactory(5);class MonarchLineState{constructor(e,t){this.stack=e,this.embeddedLanguageData=t}clone(){return(this.embeddedLanguageData?this.embeddedLanguageData.clone():null)===this.embeddedLanguageData?this:MonarchLineStateFactory.create(this.stack,this.embeddedLanguageData)}equals(e){return e instanceof MonarchLineState&&(!!this.stack.equals(e.stack)&&(null===this.embeddedLanguageData&&null===e.embeddedLanguageData||null!==this.embeddedLanguageData&&null!==e.embeddedLanguageData&&this.embeddedLanguageData.equals(e.embeddedLanguageData)))}}class MonarchClassicTokensCollector{constructor(){this._tokens=[],this._languageId=null,this._lastTokenType=null,this._lastTokenLanguage=null}enterLanguage(e){this._languageId=e}emit(e,t){this._lastTokenType===t&&this._lastTokenLanguage===this._languageId||(this._lastTokenType=t,this._lastTokenLanguage=this._languageId,this._tokens.push(new languages.Token(e,t,this._languageId)))}nestedLanguageTokenize(e,t,n,a){const r=n.languageId,s=n.state,o=languages.TokenizationRegistry.get(r);if(!o)return this.enterLanguage(r),this.emit(a,""),s;const i=o.tokenize(e,t,s);if(0!==a)for(const e of i.tokens)this._tokens.push(new languages.Token(e.offset+a,e.type,e.language));else this._tokens=this._tokens.concat(i.tokens);return this._lastTokenType=null,this._lastTokenLanguage=null,this._languageId=null,i.endState}finalize(e){return new languages.TokenizationResult(this._tokens,e)}}class MonarchModernTokensCollector{constructor(e,t){this._languageService=e,this._theme=t,this._prependTokens=null,this._tokens=[],this._currentLanguageId=0,this._lastTokenMetadata=0}enterLanguage(e){this._currentLanguageId=this._languageService.languageIdCodec.encodeLanguageId(e)}emit(e,t){const n=this._theme.match(this._currentLanguageId,t);this._lastTokenMetadata!==n&&(this._lastTokenMetadata=n,this._tokens.push(e),this._tokens.push(n))}static _merge(e,t,n){const a=null!==e?e.length:0,r=t.length,s=null!==n?n.length:0;if(0===a&&0===r&&0===s)return new Uint32Array(0);if(0===a&&0===r)return n;if(0===r&&0===s)return e;const o=new Uint32Array(a+r+s);null!==e&&o.set(e);for(let e=0;e<r;e++)o[a+e]=t[e];return null!==n&&o.set(n,a+r),o}nestedLanguageTokenize(e,t,n,a){const r=n.languageId,s=n.state,o=languages.TokenizationRegistry.get(r);if(!o)return this.enterLanguage(r),this.emit(a,""),s;const i=o.tokenizeEncoded(e,t,s);if(0!==a)for(let e=0,t=i.tokens.length;e<t;e+=2)i.tokens[e]+=a;return this._prependTokens=MonarchModernTokensCollector._merge(this._prependTokens,this._tokens,i.tokens),this._tokens=[],this._currentLanguageId=0,this._lastTokenMetadata=0,i.endState}finalize(e){return new languages.EncodedTokenizationResult(MonarchModernTokensCollector._merge(this._prependTokens,this._tokens,null),e)}}export class MonarchTokenizer{constructor(e,t,n,a){this._languageService=e,this._standaloneThemeService=t,this._languageId=n,this._lexer=a,this._embeddedLanguages=Object.create(null),this.embeddedLoaded=Promise.resolve(void 0);let r=!1;this._tokenizationRegistryListener=languages.TokenizationRegistry.onDidChange((e=>{if(r)return;let t=!1;for(let n=0,a=e.changedLanguages.length;n<a;n++){const a=e.changedLanguages[n];if(this._embeddedLanguages[a]){t=!0;break}}t&&(r=!0,languages.TokenizationRegistry.fire([this._languageId]),r=!1)}))}dispose(){this._tokenizationRegistryListener.dispose()}getLoadStatus(){const e=[];for(let t in this._embeddedLanguages){const n=languages.TokenizationRegistry.get(t);if(n){if(n instanceof MonarchTokenizer){const t=n.getLoadStatus();!1===t.loaded&&e.push(t.promise)}}else languages.TokenizationRegistry.isResolved(t)||e.push(languages.TokenizationRegistry.getOrCreate(t))}return 0===e.length?{loaded:!0}:{loaded:!1,promise:Promise.all(e).then((e=>{}))}}getInitialState(){const e=MonarchStackElementFactory.create(null,this._lexer.start);return MonarchLineStateFactory.create(e,null)}tokenize(e,t,n){const a=new MonarchClassicTokensCollector,r=this._tokenize(e,t,n,a);return a.finalize(r)}tokenizeEncoded(e,t,n){const a=new MonarchModernTokensCollector(this._languageService,this._standaloneThemeService.getColorTheme().tokenTheme),r=this._tokenize(e,t,n,a);return a.finalize(r)}_tokenize(e,t,n,a){return n.embeddedLanguageData?this._nestedTokenize(e,t,n,0,a):this._myTokenize(e,t,n,0,a)}_findLeavingNestedLanguageOffset(e,t){let n=this._lexer.tokenizer[t.stack.state];if(!n&&(n=monarchCommon.findRules(this._lexer,t.stack.state),!n))throw monarchCommon.createError(this._lexer,"tokenizer state is not defined: "+t.stack.state);let a=-1,r=!1;for(const t of n){if(!monarchCommon.isIAction(t.action)||"@pop"!==t.action.nextEmbedded)continue;r=!0;let n=t.regex;const s=t.regex.source;if("^(?:"===s.substr(0,4)&&")"===s.substr(s.length-1,1)){const e=(n.ignoreCase?"i":"")+(n.unicode?"u":"");n=new RegExp(s.substr(4,s.length-5),e)}const o=e.search(n);-1===o||0!==o&&t.matchOnlyAtLineStart||(-1===a||o<a)&&(a=o)}if(!r)throw monarchCommon.createError(this._lexer,'no rule containing nextEmbedded: "@pop" in tokenizer embedded state: '+t.stack.state);return a}_nestedTokenize(e,t,n,a,r){const s=this._findLeavingNestedLanguageOffset(e,n);if(-1===s){const s=r.nestedLanguageTokenize(e,t,n.embeddedLanguageData,a);return MonarchLineStateFactory.create(n.stack,new EmbeddedLanguageData(n.embeddedLanguageData.languageId,s))}const o=e.substring(0,s);o.length>0&&r.nestedLanguageTokenize(o,!1,n.embeddedLanguageData,a);const i=e.substring(s);return this._myTokenize(i,t,n,a+s,r)}_safeRuleName(e){return e?e.name:"(unknown)"}_myTokenize(e,t,n,a,r){r.enterLanguage(this._languageId);const s=e.length,o=t&&this._lexer.includeLF?e+"\n":e,i=o.length;let l=n.embeddedLanguageData,h=n.stack,c=0,u=null,g=!0;for(;g||c<i;){const n=c,d=h.depth,m=u?u.groups.length:0,k=h.state;let _=null,f=null,p=null,L=null,b=null;if(u){_=u.matches;const e=u.groups.shift();f=e.matched,p=e.action,L=u.rule,0===u.groups.length&&(u=null)}else{if(!g&&c>=i)break;g=!1;let e=this._lexer.tokenizer[k];if(!e&&(e=monarchCommon.findRules(this._lexer,k),!e))throw monarchCommon.createError(this._lexer,"tokenizer state is not defined: "+k);let t=o.substr(c);for(const n of e)if((0===c||!n.matchOnlyAtLineStart)&&(_=t.match(n.regex),_)){f=_[0],p=n.action;break}}if(_||(_=[""],f=""),p||(c<i&&(_=[o.charAt(c)],f=_[0]),p=this._lexer.defaultToken),null===f)break;for(c+=f.length;monarchCommon.isFuzzyAction(p)&&monarchCommon.isIAction(p)&&p.test;)p=p.test(f,_,k,c===i);let T=null;if("string"==typeof p||Array.isArray(p))T=p;else if(p.group)T=p.group;else if(null!==p.token&&void 0!==p.token){if(T=p.tokenSubst?monarchCommon.substituteMatches(this._lexer,p.token,f,_,k):p.token,p.nextEmbedded)if("@pop"===p.nextEmbedded){if(!l)throw monarchCommon.createError(this._lexer,"cannot pop embedded language if not inside one");l=null}else{if(l)throw monarchCommon.createError(this._lexer,"cannot enter embedded language from within an embedded language");b=monarchCommon.substituteMatches(this._lexer,p.nextEmbedded,f,_,k)}if(p.goBack&&(c=Math.max(0,c-p.goBack)),p.switchTo&&"string"==typeof p.switchTo){let e=monarchCommon.substituteMatches(this._lexer,p.switchTo,f,_,k);if("@"===e[0]&&(e=e.substr(1)),!monarchCommon.findRules(this._lexer,e))throw monarchCommon.createError(this._lexer,"trying to switch to a state '"+e+"' that is undefined in rule: "+this._safeRuleName(L));h=h.switchTo(e)}else{if(p.transform&&"function"==typeof p.transform)throw monarchCommon.createError(this._lexer,"action.transform not supported");if(p.next)if("@push"===p.next){if(h.depth>=this._lexer.maxStack)throw monarchCommon.createError(this._lexer,"maximum tokenizer stack size reached: ["+h.state+","+h.parent.state+",...]");h=h.push(k)}else if("@pop"===p.next){if(h.depth<=1)throw monarchCommon.createError(this._lexer,"trying to pop an empty stack in rule: "+this._safeRuleName(L));h=h.pop()}else if("@popall"===p.next)h=h.popall();else{let e=monarchCommon.substituteMatches(this._lexer,p.next,f,_,k);if("@"===e[0]&&(e=e.substr(1)),!monarchCommon.findRules(this._lexer,e))throw monarchCommon.createError(this._lexer,"trying to set a next state '"+e+"' that is undefined in rule: "+this._safeRuleName(L));h=h.push(e)}}p.log&&"string"==typeof p.log&&monarchCommon.log(this._lexer,this._lexer.languageId+": "+monarchCommon.substituteMatches(this._lexer,p.log,f,_,k))}if(null===T)throw monarchCommon.createError(this._lexer,"lexer rule has no well-defined action in rule: "+this._safeRuleName(L));const x=n=>{const s=this._languageService.getLanguageIdByLanguageName(n)||this._languageService.getLanguageIdByMimeType(n)||n,o=this._getNestedEmbeddedLanguageData(s);if(c<i){const n=e.substr(c);return this._nestedTokenize(n,t,MonarchLineStateFactory.create(h,o),a+c,r)}return MonarchLineStateFactory.create(h,o)};if(Array.isArray(T)){if(u&&u.groups.length>0)throw monarchCommon.createError(this._lexer,"groups cannot be nested: "+this._safeRuleName(L));if(_.length!==T.length+1)throw monarchCommon.createError(this._lexer,"matched number of groups does not match the number of actions in rule: "+this._safeRuleName(L));let e=0;for(let t=1;t<_.length;t++)e+=_[t].length;if(e!==f.length)throw monarchCommon.createError(this._lexer,"with groups, all characters should be matched in consecutive groups in rule: "+this._safeRuleName(L));u={rule:L,matches:_,groups:[]};for(let e=0;e<T.length;e++)u.groups[e]={action:T[e],matched:_[e+1]};c-=f.length}else{{if("@rematch"===T&&(c-=f.length,f="",_=null,T="",null!==b))return x(b);if(0===f.length){if(0===i||d!==h.depth||k!==h.state||(u?u.groups.length:0)!==m)continue;throw monarchCommon.createError(this._lexer,"no progress in tokenizer in rule: "+this._safeRuleName(L))}let e=null;if(monarchCommon.isString(T)&&0===T.indexOf("@brackets")){const t=T.substr("@brackets".length),n=findBracket(this._lexer,f);if(!n)throw monarchCommon.createError(this._lexer,"@brackets token returned but no bracket defined as: "+f);e=monarchCommon.sanitize(n.token+t)}else{const t=""===T?"":T+this._lexer.tokenPostfix;e=monarchCommon.sanitize(t)}n<s&&r.emit(n+a,e)}if(null!==b)return x(b)}}return MonarchLineStateFactory.create(h,l)}_getNestedEmbeddedLanguageData(e){if(!this._languageService.isRegisteredLanguageId(e))return new EmbeddedLanguageData(e,NullState);e!==this._languageId&&(languages.TokenizationRegistry.getOrCreate(e),this._embeddedLanguages[e]=!0);const t=languages.TokenizationRegistry.get(e);return new EmbeddedLanguageData(e,t?t.getInitialState():NullState)}}function findBracket(e,t){if(!t)return null;t=monarchCommon.fixCase(e,t);const n=e.brackets;for(const e of n){if(e.open===t)return{token:e.token,bracketType:1};if(e.close===t)return{token:e.token,bracketType:-1}}return null}
//# sourceMappingURL=/sm/a1e8620c0c9f16f22526e0d638195c277f35955f544ce26c66e116d4badcaa04.map