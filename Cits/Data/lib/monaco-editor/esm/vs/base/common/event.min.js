/**
 * Minified by jsDelivr using Terser v5.10.0.
 * Original file: /npm/monaco-editor@0.33.0/esm/vs/base/common/event.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import{onUnexpectedError}from"./errors.js";import{combinedDisposable,Disposable,DisposableStore,SafeDisposable,toDisposable}from"./lifecycle.js";import{LinkedList}from"./linkedList.js";import{StopWatch}from"./stopwatch.js";let _enableDisposeWithListenerWarning=!1,_enableSnapshotPotentialLeakWarning=!1;export var Event;!function(e){function t(e){if(_enableSnapshotPotentialLeakWarning){const{onListenerDidAdd:t}=e,s=Stacktrace.create();let i=0;e.onListenerDidAdd=()=>{2==++i&&(console.warn("snapshotted emitter LIKELY used public and SHOULD HAVE BEEN created with DisposableStore. snapshotted here"),s.print()),null==t||t()}}}function s(e){return(t,s=null,i)=>{let n,r=!1;return n=e((e=>{if(!r)return n?n.dispose():r=!0,t.call(s,e)}),null,i),r&&n.dispose(),n}}function i(e,t,s){return l(((s,i=null,n)=>e((e=>s.call(i,t(e))),null,n)),s)}function n(e,t,s){return l(((s,i=null,n)=>e((e=>{t(e),s.call(i,e)}),null,n)),s)}function r(e,t,s){return l(((s,i=null,n)=>e((e=>t(e)&&s.call(i,e)),null,n)),s)}function o(e,t,s,n){let r=s;return i(e,(e=>(r=t(r,e),r)),n)}function l(e,s){let i;const n={onFirstListenerAdd(){i=e(r.fire,r)},onLastListenerRemove(){i.dispose()}};s||t(n);const r=new Emitter(n);return s&&s.add(r),r.event}function a(e,s,i=100,n=!1,r,o){let l,a,h,u=0;const c={leakWarningThreshold:r,onFirstListenerAdd(){l=e((e=>{u++,a=s(a,e),n&&!h&&(d.fire(a),a=void 0),clearTimeout(h),h=setTimeout((()=>{const e=a;a=void 0,h=void 0,(!n||u>1)&&d.fire(e),u=0}),i)}))},onLastListenerRemove(){l.dispose()}};o||t(c);const d=new Emitter(c);return o&&o.add(d),d.event}function h(e,t=((e,t)=>e===t),s){let i,n=!0;return r(e,(e=>{const s=n||!t(e,i);return n=!1,i=e,s}),s)}e.None=()=>Disposable.None,e.once=s,e.map=i,e.forEach=n,e.filter=r,e.signal=function(e){return e},e.any=function(...e){return(t,s=null,i)=>combinedDisposable(...e.map((e=>e((e=>t.call(s,e)),null,i))))},e.reduce=o,e.debounce=a,e.latch=h,e.split=function(t,s,i){return[e.filter(t,s,i),e.filter(t,(e=>!s(e)),i)]},e.buffer=function(e,t=!1,s=[]){let i=s.slice(),n=e((e=>{i?i.push(e):o.fire(e)}));const r=()=>{i&&i.forEach((e=>o.fire(e))),i=null},o=new Emitter({onFirstListenerAdd(){n||(n=e((e=>o.fire(e))))},onFirstListenerDidAdd(){i&&(t?setTimeout(r):r())},onLastListenerRemove(){n&&n.dispose(),n=null}});return o.event};class u{constructor(e){this.event=e}map(e){return new u(i(this.event,e))}forEach(e){return new u(n(this.event,e))}filter(e){return new u(r(this.event,e))}reduce(e,t){return new u(o(this.event,e,t))}latch(){return new u(h(this.event))}debounce(e,t=100,s=!1,i){return new u(a(this.event,e,t,s,i))}on(e,t,s){return this.event(e,t,s)}once(e,t,i){return s(this.event)(e,t,i)}}e.chain=function(e){return new u(e)},e.fromNodeEventEmitter=function(e,t,s=(e=>e)){const i=(...e)=>n.fire(s(...e)),n=new Emitter({onFirstListenerAdd:()=>e.on(t,i),onLastListenerRemove:()=>e.removeListener(t,i)});return n.event},e.fromDOMEventEmitter=function(e,t,s=(e=>e)){const i=(...e)=>n.fire(s(...e)),n=new Emitter({onFirstListenerAdd:()=>e.addEventListener(t,i),onLastListenerRemove:()=>e.removeEventListener(t,i)});return n.event},e.toPromise=function(e){return new Promise((t=>s(e)(t)))},e.runAndSubscribe=function(e,t){return t(void 0),e((e=>t(e)))},e.runAndSubscribeWithStore=function(e,t){let s=null;function i(e){null==s||s.dispose(),s=new DisposableStore,t(e,s)}i(void 0);const n=e((e=>i(e)));return toDisposable((()=>{n.dispose(),null==s||s.dispose()}))}}(Event||(Event={}));class EventProfiling{constructor(e){this._listenerCount=0,this._invocationCount=0,this._elapsedOverall=0,this._name=`${e}_${EventProfiling._idPool++}`}start(e){this._stopWatch=new StopWatch(!0),this._listenerCount=e}stop(){if(this._stopWatch){const e=this._stopWatch.elapsed();this._elapsedOverall+=e,this._invocationCount+=1,console.info(`did FIRE ${this._name}: elapsed_ms: ${e.toFixed(5)}, listener: ${this._listenerCount} (elapsed_overall: ${this._elapsedOverall.toFixed(2)}, invocations: ${this._invocationCount})`),this._stopWatch=void 0}}}EventProfiling._idPool=0;let _globalLeakWarningThreshold=-1;class LeakageMonitor{constructor(e,t=Math.random().toString(18).slice(2,5)){this.customThreshold=e,this.name=t,this._warnCountdown=0}dispose(){this._stacks&&this._stacks.clear()}check(e,t){let s=_globalLeakWarningThreshold;if("number"==typeof this.customThreshold&&(s=this.customThreshold),s<=0||t<s)return;this._stacks||(this._stacks=new Map);const i=this._stacks.get(e.value)||0;if(this._stacks.set(e.value,i+1),this._warnCountdown-=1,this._warnCountdown<=0){let e;this._warnCountdown=.5*s;let i=0;for(const[t,s]of this._stacks)(!e||i<s)&&(e=t,i=s);console.warn(`[${this.name}] potential listener LEAK detected, having ${t} listeners already. MOST frequent listener (${i}):`),console.warn(e)}return()=>{const t=this._stacks.get(e.value)||0;this._stacks.set(e.value,t-1)}}}class Stacktrace{constructor(e){this.value=e}static create(){var e;return new Stacktrace(null!==(e=(new Error).stack)&&void 0!==e?e:"")}print(){console.warn(this.value.split("\n").slice(2).join("\n"))}}class Listener{constructor(e,t,s){this.callback=e,this.callbackThis=t,this.stack=s,this.subscription=new SafeDisposable}invoke(e){this.callback.call(this.callbackThis,e)}}export class Emitter{constructor(e){var t;this._disposed=!1,this._options=e,this._leakageMon=_globalLeakWarningThreshold>0?new LeakageMonitor(this._options&&this._options.leakWarningThreshold):void 0,this._perfMon=(null===(t=this._options)||void 0===t?void 0:t._profName)?new EventProfiling(this._options._profName):void 0}dispose(){var e,t,s,i;if(!this._disposed){if(this._disposed=!0,this._listeners){if(_enableDisposeWithListenerWarning){const e=Array.from(this._listeners);queueMicrotask((()=>{var t;for(const s of e)s.subscription.isset()&&(s.subscription.unset(),null===(t=s.stack)||void 0===t||t.print())}))}this._listeners.clear()}null===(e=this._deliveryQueue)||void 0===e||e.clear(),null===(s=null===(t=this._options)||void 0===t?void 0:t.onLastListenerRemove)||void 0===s||s.call(t),null===(i=this._leakageMon)||void 0===i||i.dispose()}}get event(){return this._event||(this._event=(e,t,s)=>{var i,n,r;this._listeners||(this._listeners=new LinkedList);const o=this._listeners.isEmpty();let l,a;o&&(null===(i=this._options)||void 0===i?void 0:i.onFirstListenerAdd)&&this._options.onFirstListenerAdd(this),this._leakageMon&&this._listeners.size>=30&&(a=Stacktrace.create(),l=this._leakageMon.check(a,this._listeners.size+1)),_enableDisposeWithListenerWarning&&(a=null!=a?a:Stacktrace.create());const h=new Listener(e,t,a),u=this._listeners.push(h);o&&(null===(n=this._options)||void 0===n?void 0:n.onFirstListenerDidAdd)&&this._options.onFirstListenerDidAdd(this),(null===(r=this._options)||void 0===r?void 0:r.onListenerDidAdd)&&this._options.onListenerDidAdd(this,e,t);const c=h.subscription.set((()=>{if(l&&l(),!this._disposed&&(u(),this._options&&this._options.onLastListenerRemove)){this._listeners&&!this._listeners.isEmpty()||this._options.onLastListenerRemove(this)}}));return s instanceof DisposableStore?s.add(c):Array.isArray(s)&&s.push(c),c}),this._event}fire(e){var t,s;if(this._listeners){this._deliveryQueue||(this._deliveryQueue=new LinkedList);for(let t of this._listeners)this._deliveryQueue.push([t,e]);for(null===(t=this._perfMon)||void 0===t||t.start(this._deliveryQueue.size);this._deliveryQueue.size>0;){const[e,t]=this._deliveryQueue.shift();try{e.invoke(t)}catch(e){onUnexpectedError(e)}}null===(s=this._perfMon)||void 0===s||s.stop()}}}export class PauseableEmitter extends Emitter{constructor(e){super(e),this._isPaused=0,this._eventQueue=new LinkedList,this._mergeFn=null==e?void 0:e.merge}pause(){this._isPaused++}resume(){if(0!==this._isPaused&&0==--this._isPaused)if(this._mergeFn){const e=Array.from(this._eventQueue);this._eventQueue.clear(),super.fire(this._mergeFn(e))}else for(;!this._isPaused&&0!==this._eventQueue.size;)super.fire(this._eventQueue.shift())}fire(e){this._listeners&&(0!==this._isPaused?this._eventQueue.push(e):super.fire(e))}}export class DebounceEmitter extends PauseableEmitter{constructor(e){var t;super(e),this._delay=null!==(t=e.delay)&&void 0!==t?t:100}fire(e){this._handle||(this.pause(),this._handle=setTimeout((()=>{this._handle=void 0,this.resume()}),this._delay)),super.fire(e)}}export class EventBufferer{constructor(){this.buffers=[]}wrapEvent(e){return(t,s,i)=>e((e=>{const i=this.buffers[this.buffers.length-1];i?i.push((()=>t.call(s,e))):t.call(s,e)}),void 0,i)}bufferEvents(e){const t=[];this.buffers.push(t);const s=e();return this.buffers.pop(),t.forEach((e=>e())),s}}export class Relay{constructor(){this.listening=!1,this.inputEvent=Event.None,this.inputEventListener=Disposable.None,this.emitter=new Emitter({onFirstListenerDidAdd:()=>{this.listening=!0,this.inputEventListener=this.inputEvent(this.emitter.fire,this.emitter)},onLastListenerRemove:()=>{this.listening=!1,this.inputEventListener.dispose()}}),this.event=this.emitter.event}set input(e){this.inputEvent=e,this.listening&&(this.inputEventListener.dispose(),this.inputEventListener=e(this.emitter.fire,this.emitter))}dispose(){this.inputEventListener.dispose(),this.emitter.dispose()}}
//# sourceMappingURL=/sm/43ff797598342a1cd8d43a65d121c70b6654458ad410f6dbc6f83ea7745c9c31.map