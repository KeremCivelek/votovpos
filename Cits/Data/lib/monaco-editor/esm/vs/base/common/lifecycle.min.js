/**
 * Minified by jsDelivr using Terser v5.10.0.
 * Original file: /npm/monaco-editor@0.33.0/esm/vs/base/common/lifecycle.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import{once}from"./functional.js";import{Iterable}from"./iterator.js";const TRACK_DISPOSABLES=!1;let disposableTracker=null;export function setDisposableTracker(s){disposableTracker=s}function trackDisposable(s){return null==disposableTracker||disposableTracker.trackDisposable(s),s}function markAsDisposed(s){null==disposableTracker||disposableTracker.markAsDisposed(s)}function setParentOfDisposable(s,e){null==disposableTracker||disposableTracker.setParent(s,e)}function setParentOfDisposables(s,e){if(disposableTracker)for(const i of s)disposableTracker.setParent(i,e)}export function markAsSingleton(s){return null==disposableTracker||disposableTracker.markAsSingleton(s),s}export class MultiDisposeError extends Error{constructor(s){super(`Encountered errors while disposing of store. Errors: [${s.join(", ")}]`),this.errors=s}}export function isDisposable(s){return"function"==typeof s.dispose&&0===s.dispose.length}export function dispose(s){if(Iterable.is(s)){let e=[];for(const i of s)if(i)try{i.dispose()}catch(s){e.push(s)}if(1===e.length)throw e[0];if(e.length>1)throw new MultiDisposeError(e);return Array.isArray(s)?[]:s}if(s)return s.dispose(),s}export function combinedDisposable(...s){const e=toDisposable((()=>dispose(s)));return setParentOfDisposables(s,e),e}export function toDisposable(s){const e=trackDisposable({dispose:once((()=>{markAsDisposed(e),s()}))});return e}export class DisposableStore{constructor(){this._toDispose=new Set,this._isDisposed=!1,trackDisposable(this)}dispose(){this._isDisposed||(markAsDisposed(this),this._isDisposed=!0,this.clear())}get isDisposed(){return this._isDisposed}clear(){try{dispose(this._toDispose.values())}finally{this._toDispose.clear()}}add(s){if(!s)return s;if(s===this)throw new Error("Cannot register a disposable on itself!");return setParentOfDisposable(s,this),this._isDisposed?DisposableStore.DISABLE_DISPOSED_WARNING||console.warn(new Error("Trying to add a disposable to a DisposableStore that has already been disposed of. The added object will be leaked!").stack):this._toDispose.add(s),s}}DisposableStore.DISABLE_DISPOSED_WARNING=!1;export class Disposable{constructor(){this._store=new DisposableStore,trackDisposable(this),setParentOfDisposable(this._store,this)}dispose(){markAsDisposed(this),this._store.dispose()}_register(s){if(s===this)throw new Error("Cannot register a disposable on itself!");return this._store.add(s)}}Disposable.None=Object.freeze({dispose(){}});export class MutableDisposable{constructor(){this._isDisposed=!1,trackDisposable(this)}get value(){return this._isDisposed?void 0:this._value}set value(s){var e;this._isDisposed||s===this._value||(null===(e=this._value)||void 0===e||e.dispose(),s&&setParentOfDisposable(s,this),this._value=s)}clear(){this.value=void 0}dispose(){var s;this._isDisposed=!0,markAsDisposed(this),null===(s=this._value)||void 0===s||s.dispose(),this._value=void 0}clearAndLeak(){const s=this._value;return this._value=void 0,s&&setParentOfDisposable(s,null),s}}export class SafeDisposable{constructor(){this.dispose=()=>{},this.unset=()=>{},this.isset=()=>!1,trackDisposable(this)}set(s){let e=s;return this.unset=()=>e=void 0,this.isset=()=>void 0!==e,this.dispose=()=>{e&&(e(),e=void 0,markAsDisposed(this))},this}}export class ImmortalReference{constructor(s){this.object=s}dispose(){}}
//# sourceMappingURL=/sm/b0b96dda95ebee020d3646724d962b7e06e8ba64aa227df6d68083a76255cee1.map