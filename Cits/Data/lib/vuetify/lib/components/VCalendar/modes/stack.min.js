/**
 * Minified by jsDelivr using Terser v5.13.1.
 * Original file: /npm/vuetify@2.6.6/lib/components/VCalendar/modes/stack.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import{getOverlapGroupHandler,getVisuals,hasOverlap,getNormalizedRange}from"./common";import{getTimestampIdentifier}from"../util/timestamp";const FULL_WIDTH=100,DEFAULT_OFFSET=5,WIDTH_MULTIPLIER=1.7;export const stack=(t,e,n)=>{const r=getOverlapGroupHandler(e);return(t,e,i,s)=>{if(!i)return r.getVisuals(t,e,i,s);const a=getTimestampIdentifier(t),o=getVisuals(e,a),l=getGroups(o,a);for(const t of l){const e=[];for(const r of t.visuals){const t=getNode(r,a),i=getNextIndex(t,e);if(!1===i){const r=getParent(t,e);r&&(t.parent=r,t.sibling=hasOverlap(t.start,t.end,r.start,addTime(r.start,n)),t.index=r.index+1,r.children.push(t))}else{const[r]=getOverlappingRange(t,e,i-1,i-1),s=getOverlappingRange(t,e,i+1,i+e.length,!0);t.children=s,t.index=i,r&&(t.parent=r,t.sibling=hasOverlap(t.start,t.end,r.start,addTime(r.start,n)),r.children.push(t));for(const e of s){e.parent===r&&(e.parent=t);e.index-t.index<=1&&t.sibling&&hasOverlap(t.start,addTime(t.start,n),e.start,e.end)&&(e.sibling=!0)}}e.push(t)}calculateBounds(e,n)}return o.sort(((t,e)=>t.left-e.left||t.event.startTimestampIdentifier-e.event.startTimestampIdentifier)),o}};function calculateBounds(t,e){for(const n of t){const{visual:r,parent:i}=n,s=getMaxChildIndex(n)+1,a=i?i.visual.left:0,o=100-a,l=Math.min(5,100/s),d=getColumnWidthMultiplier(n,t),u=o/(s-n.index+1),c=o/(s-n.index+(n.sibling?1:0))*d;i&&(r.left=n.sibling?a+u:a+l),r.width=hasFullWidth(n,t,e)?100-r.left:Math.min(100-r.left,1.7*c)}}function getColumnWidthMultiplier(t,e){if(!t.children.length)return 1;const n=t.index+e.length;return t.children.reduce(((t,e)=>Math.min(t,e.index)),n)-t.index}function getOverlappingIndices(t,e){const n=[];for(const r of e)hasOverlap(t.start,t.end,r.start,r.end)&&n.push(r.index);return n}function getNextIndex(t,e){const n=getOverlappingIndices(t,e);n.sort();for(let t=0;t<n.length;t++)if(t<n[t])return t;return!1}function getOverlappingRange(t,e,n,r,i=!1){const s=[];for(const i of e)i.index>=n&&i.index<=r&&hasOverlap(t.start,t.end,i.start,i.end)&&s.push(i);if(i&&s.length>0){const t=s.reduce(((t,e)=>Math.min(t,e.index)),s[0].index);return s.filter((e=>e.index===t))}return s}function getParent(t,e){let n=null;for(const r of e)hasOverlap(t.start,t.end,r.start,r.end)&&(null===n||r.index>n.index)&&(n=r);return n}function hasFullWidth(t,e,n){for(const r of e)if(r!==t&&r.index>t.index&&hasOverlap(t.start,addTime(t.start,n),r.start,r.end))return!1;return!0}function getGroups(t,e){const n=[];for(const r of t){const[t,i]=getNormalizedRange(r.event,e);let s=!1;for(const e of n)if(hasOverlap(t,i,e.start,e.end)){e.visuals.push(r),e.end=Math.max(e.end,i),s=!0;break}s||n.push({start:t,end:i,visuals:[r]})}return n}function getNode(t,e){const[n,r]=getNormalizedRange(t.event,e);return{parent:null,sibling:!0,index:0,visual:t,start:n,end:r,children:[]}}function getMaxChildIndex(t){let e=t.index;for(const n of t.children){const t=getMaxChildIndex(n);t>e&&(e=t)}return e}function addTime(t,e){const n=t%100,r=n+e;return t-n+100*Math.floor(r/60)+r%60}
//# sourceMappingURL=/sm/e1c50453ddaebc03ade37a42c5907e12530a45f11f6e3687c3270e268d036296.map